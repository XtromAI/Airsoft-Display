

# **Comparative Analysis of Display Libraries for SH1107 OLEDs on Raspberry Pi Pico**

### **Executive Summary**

This report presents a comprehensive comparative analysis of prominent C/C++ display driver libraries tailored for monochrome OLEDs utilizing the SH1107 controller, specifically when interfaced with the Raspberry Pi Pico (RP2040) microcontroller. The evaluation critically assesses the Adafruit display ecosystem, including its GFX and SH110X libraries, against leading alternatives such as U8g2/U8x8, Waveshare's proprietary C++ drivers, and the mcu-renderer library. The assessment encompasses architectural design, graphics capabilities, font rendering, memory efficiency, performance characteristics, and integration nuances with the Pico SDK. Key findings indicate that each library offers distinct advantages, with trade-offs in ease of integration, resource consumption, and graphical sophistication. Recommendations are provided to guide developers in selecting the most appropriate library based on project-specific requirements, balancing factors such as memory constraints, performance demands, and the complexity of graphical output.

### **Introduction**

#### **Purpose and Scope of the Report**

This report provides a detailed technical comparison of prominent C/C++ display driver libraries for monochrome OLEDs, specifically focusing on the SH1107 controller, when interfaced with the Raspberry Pi Pico (RP2040) microcontroller. The primary objective is to evaluate the Adafruit display ecosystem against alternatives such as U8g2/U8x8, Waveshare's proprietary drivers, and mcu-renderer, assessing their architectural design, graphics capabilities, font rendering, memory efficiency, performance, and integration nuances with the Pico SDK. The analysis aims to equip embedded systems developers with a foundational understanding to make informed decisions regarding library selection for their RP2040-based display projects.

#### **Overview of SH1107 OLED Displays and Raspberry Pi Pico (RP2040)**

SH1107 OLED displays are compact monochrome graphic displays, typically featuring resolutions of 128x64 or 128x128 pixels. These displays are highly valued in embedded systems for their self-emission properties, which contribute to high contrast, wide viewing angles, and inherently low power consumption, as they do not require a backlight.1 The underlying SH1107 controller integrates a 128x128 bit SRAM, contrast control mechanisms, and an efficient DC-DC converter. This integration reduces the need for external components and optimizes power usage, making these displays suitable for a wide range of portable applications.4 Communication with the SH1107 typically occurs via either I2C or SPI interfaces, with SPI generally offering faster data transfer rates, which is advantageous for dynamic visual updates.1 For instance, the Waveshare Pico-OLED-1.3 module, a common SH1107-based display, operates at a 64x128 resolution, thus utilizing only half of the SH1107 controller's internal SRAM.5

The Raspberry Pi Pico, powered by the RP2040 microcontroller, serves as a low-cost yet highly flexible development platform. The RP2040 chip is distinguished by its dual ARM Cortex-M0+ cores, a substantial 264KB of on-chip SRAM, and a rich array of integrated peripherals. These peripherals include two SPI controllers, two I2C controllers, two UARTs, and 16 controllable PWM channels, providing extensive connectivity and control options for embedded projects.7 Development on the Pico is facilitated by official support for C/C++ and MicroPython, complemented by a straightforward drag-and-drop programming mechanism via USB mass storage.7 The Pico SDK further simplifies hardware interaction by offering a comprehensive library of C macros and functions that abstract low-level register settings into more accessible function calls for managing GPIO, SPI, I2C, and other hardware components.9

The selection of an appropriate display library is a critical design consideration for resource-constrained microcontrollers like the RP2040, even with its relatively generous 264KB of SRAM. A 128x128 monochrome display, for example, requires 2KB of SRAM for a full framebuffer.10 While this might appear to be a small fraction (less than 1%) of the RP2040's total RAM, a complex embedded application will also demand significant memory for its own variables, stacks, heap, and potentially other peripheral buffers. For instance, applications involving networking, extensive sensor data processing, or complex real-time algorithms will consume additional memory. Therefore, the library's approach to memory management—whether it employs a full buffer, a page buffer, or a direct-write method—can significantly impact the overall available RAM for the application logic. This highlights a fundamental design trade-off: libraries that offer a simpler, more direct drawing experience (often associated with full-buffer implementations) may consume more RAM, potentially limiting space for other application features. Conversely, libraries that prioritize memory efficiency through page-buffering or direct-write mechanisms may introduce greater complexity in drawing operations but preserve valuable RAM for other system functions.

### **Adafruit Display Library Ecosystem**

#### **Adafruit GFX Library**

The Adafruit GFX library serves as a foundational graphics engine, providing a standardized set of drawing primitives and a consistent Application Programming Interface (API) across a diverse range of Adafruit LCD, OLED, and LED matrix displays.12 This architectural approach significantly simplifies the process of adapting Arduino sketches between different display types, promoting code reusability. Developed in C++ for the Arduino environment, the library's design prioritizes portability, necessitating the re-implementation of low-level pin access functions when porting to alternative microcontroller platforms.12 The library employs a standard computer graphics coordinate system, with the origin (0,0) located at the top-left corner, and positive X and Y values extending rightward and downward, respectively.12 For monochrome displays, color representation is simplified to binary values: '1' typically signifies a "set" pixel (illuminated on OLEDs), while '0' represents a "clear" pixel (the default background state).12

Adafruit GFX offers a comprehensive suite of drawing functions to render various graphical elements. These include drawPixel(x, y, color) for individual points, drawLine(x1, y1, x2, y2, color) for connecting two points, and a range of functions for drawing and filling geometric shapes. Rectangles can be rendered as outlines using drawRect() or filled entirely with fillRect(). Similarly, circles are supported with drawCircle() for outlines and fillCircle() for solid shapes. The library also extends to more complex primitives such as triangles (drawTriangle(), fillTriangle()) and rounded rectangles (drawRoundRect(), fillRoundRect()).17 All drawing operations are performed on an internal framebuffer. Consequently, visual changes are not immediately apparent on the physical display until an explicit

display() or show() function call is executed, which transfers the buffer content to the screen.10

Regarding text rendering, the Adafruit GFX library includes a standard fixed-size font. Additionally, it supports a variety of alternate bitmap fonts derived from the GNU FreeFont project. These custom fonts are organized into "Serif," "Sans," and "Mono" faces, available in different styles (e.g., bold, italic) and various point sizes (e.g., 9, 12, 18, 24 point).19 The font data is stored as

.h files within a dedicated "Fonts" folder in the library's directory.19 To activate a custom font for subsequent text operations, the

setFont() function is utilized, requiring the address of the desired font structure as an argument.19 A key distinction when using custom fonts is the behavior of the

setCursor() function: it positions the *baseline* of the text, contrasting with the *top-left corner* positioning used by the classic built-in font.19 A critical characteristic of custom fonts in Adafruit GFX is their lack of support for a background color option; any value provided for background color will be disregarded.19 To effectively update dynamic text and clear its previous rendition, developers must either manually determine the text boundaries using

getTextBounds() and then erase the area with fillRect(), or render the text to an offscreen GFXcanvas1 object and subsequently copy this bitmap to the display using drawBitmap().19 Font files can consume substantial Flash memory, with larger fonts requiring more storage space.19 On microcontrollers with limited Flash, such as older Arduino Nano boards, loading multiple custom fonts can rapidly exhaust available program memory.23

The design of the Adafruit GFX library, particularly its approach to custom font rendering, presents a notable complexity and potential overhead when handling dynamic text. The absence of built-in background color support for custom fonts, coupled with the shift in cursor positioning (from top-left to baseline), necessitates additional developer effort. To achieve visually clean, flicker-free text updates, developers are compelled to either implement manual area clearing routines or utilize an offscreen canvas. The manual fillRect() method, while memory-efficient, can introduce noticeable screen flicker, particularly during rapid updates, which compromises the user experience. Conversely, employing an offscreen GFXcanvas1 object provides flicker-free updates, a desirable quality for polished user interfaces. However, this approach requires an additional framebuffer in RAM. For example, a 128x32 GFXcanvas1 consumes 512 bytes of RAM 19, and a full-size canvas for a 128x128 display would effectively double the display buffer's memory footprint to 4KB. This architectural choice, likely made to maintain a simpler, universal drawing pipeline across diverse display types, implicitly pushes developers towards more memory-intensive solutions or compromises on visual quality. While the Raspberry Pi Pico's generous 264KB of SRAM mitigates the direct impact of these memory demands compared to smaller Arduino boards, it still represents a fixed overhead that could be a consideration for highly complex applications where every byte of RAM is critical for other core functionalities.

#### **Adafruit SH110X Library**

The Adafruit SH110X library is specifically engineered to drive monochrome OLED displays that incorporate either the SH1107 or SH1106G driver chips.24 This library offers robust support for both I2C and SPI communication protocols, providing flexibility in hardware interfacing.18 It includes multiple constructors to accommodate various interface configurations, such as I2C, software bit-banging SPI, and native hardware SPI.27 A fundamental step in using this library is calling the

begin() function, which is responsible for allocating the necessary RAM for the display's image buffer and initializing the associated peripherals and pins.27 The library encapsulates the specific initialization sequence for the SH1107 controller, including commands for display on/off, setting the display clock divider, configuring memory mode, and adjusting contrast settings.27

For SPI-interfaced SH110X displays, the library's constructors require the specification of pins for MOSI (Master Out, Slave In), SCLK (Serial Clock), DC (Data/Command), RST (Reset), and CS (Chip Select).27 The DC pin is crucial for differentiating between command bytes (when held low) and display data bytes (when held high) transmitted over the SPI bus.18 The RST pin enables a hardware reset of the display; if the display module does not provide or require an external reset, this parameter can be set to \-1.27 When utilizing native hardware SPI, the constructor accepts a pointer to an existing

SPIClass instance and allows for a configurable bitrate, with an 8 MHz default.18 The

display() function serves as the mechanism by which the contents of the internal RAM buffer are transferred to the physical SH1107 display, making all preceding drawing operations visible on the screen.18

The Adafruit SH110X library employs a full framebuffer strategy, meaning it allocates a contiguous block of RAM to mirror the entire display content. For a 128x128 pixel monochrome SH1107 display, this necessitates an allocation of 2KB of SRAM (calculated as 128 pixels \* 128 pixels / 8 bits per byte \= 2048 bytes).10 This substantial memory requirement renders the library unsuitable for microcontrollers with very limited RAM, such as the Arduino Uno (which typically possesses only 2KB of SRAM, making the display buffer alone consume all available dynamic memory). Instead, it mandates the use of development boards with 16KB or more RAM, such as those based on SAMD21, ESP, or nRF52 microcontrollers.10 The Raspberry Pi Pico, with its 264KB of SRAM, is well-equipped to handle this 2KB framebuffer without significant memory strain.7 The

display() function efficiently transfers the entire buffer to the screen in a single, blocking operation.10

Adafruit's decision to implement a full framebuffer within the SH110X library, while simplifying the drawing model for developers (who draw to an off-screen buffer and then push it all at once), inherently ties the library's RAM consumption directly to the display's resolution. This design, although easily manageable on the RP2040 due to its ample SRAM, signifies a prioritization of straightforward API usage over extreme memory optimization. The default 8MHz SPI bitrate 18 indicates a focus on maximizing data transfer speed, which is beneficial for achieving smooth display updates. However, the documentation notes that

yield() calls may be necessary on some microcontrollers during the display() operation to prevent watchdog resets.26 This suggests that this blocking transfer can consume a noticeable amount of CPU time. In real-time embedded applications, such blocking operations could potentially impact the responsiveness of other critical tasks if not carefully managed. While the high SPI speed ensures rapid data transfer, the total time spent transferring a 2KB buffer can still be significant, prompting developers to consider asynchronous or DMA-based transfers if strict real-time deadlines are in place, although direct DMA support for the SH110X library is not explicitly detailed in the provided information.

### **Alternative Display Libraries for RP2040**

#### **U8g2/U8x8 Library**

U8g2 (Universal 8-bit Graphics Library) is a highly versatile and open-source monochrome graphics library specifically designed for embedded devices. It boasts extensive support for over 100 display controllers, including the SH1107.3 A key strength of U8g2 lies in its distinct memory management strategies, which cater to a wide range of microcontroller capabilities:

* **"Full Buffer" Mode:** In this mode, typically indicated by \_F in constructor names (e.g., U8G2\_SH1107\_64X128\_F\_HW\_I2C), U8g2 utilizes an internal memory buffer that holds the entire display content. All drawing operations are performed on this buffer, which is then transferred to the physical display in a single operation.31 This mode simplifies complex graphics rendering and provides flicker-free updates.  
* **"Page Buffer" Mode:** This mode, often denoted by \_1 or \_2 in constructors (e.g., U8G2\_SH1107\_64X128\_1\_HW\_I2C), updates the display in smaller, manageable sections or "pages." This approach significantly reduces the RAM footprint required for the display buffer, making it particularly suitable for microcontrollers with very limited memory.31 Drawing operations are iterated page by page using functions like  
  firstPage() and nextPage().  
* **U8x8 Library:** U8x8 is a lightweight, text-only subset of U8g2. Its defining characteristic is its "direct write" approach, meaning it communicates directly with the display controller without requiring any internal RAM buffer for graphics or text. This makes U8x8 exceptionally memory-efficient for applications primarily focused on displaying textual information.3

U8g2 provides a comprehensive set of graphics primitives, including functions for drawing lines, circles, boxes, and bitmaps, enabling a wide range of visual outputs.30 A standout feature of U8g2 is its extensive font support, offering a vast collection of pre-rendered fonts with virtually no restriction on font height.3 These fonts are highly compressed, which results in a smaller Flash memory footprint compared to comparable fonts in Adafruit GFX.39 While this compression might lead to slightly slower text rendering due to decompression overhead 40, the memory savings are often a critical advantage in embedded systems where Flash memory is a finite resource. U8g2's font list includes various pixel heights (e.g., 3, 4, 5, 8, 13-16 pixels) and supports diverse character sets.41

The flexible memory modes of U8g2 are its primary strength for memory optimization. The page buffer mode is a key feature for working with microcontrollers that have very limited RAM.31 For instance, while a 128x64 display might require 1KB for a full buffer, page buffering can reduce this significantly, sometimes to as little as 128 or 256 bytes depending on the page size.33 U8x8 further minimizes memory usage by eliminating the display buffer entirely for text-only output, making it the most RAM-efficient option.3 The use of compressed fonts also contributes to a lower Flash memory footprint, freeing up space for application code.39

To port the U8g2 library to a new microcontroller platform like the bare-metal Raspberry Pi Pico (RP2040), developers are required to implement two crucial callback functions for its Hardware Abstraction Layer (HAL): a "uC specific" GPIO and Delay callback, and a u8x8 byte communication callback.30 The GPIO and Delay Callback (

u8x8\_msg\_cb) is responsible for handling all messages related to GPIO operations (setting/resetting pins for Chip Select, Data/Command, Reset, and software SPI clock/data lines) and implementing busy-wait delays. Messages such as U8X8\_MSG\_DELAY\_MILLI (for millisecond delays), U8X8\_MSG\_DELAY\_NANO (for nanosecond delays, critical for bit-banging), U8X8\_MSG\_GPIO\_CS, U8X8\_MSG\_GPIO\_DC, and U8X8\_MSG\_GPIO\_RESET are processed within this callback.30 For the RP2040, these messages would be mapped to corresponding Pico SDK functions like

sleep\_ms(), gpio\_put(), and gpio\_set\_function().9 The Byte Communication Callback (

u8x8\_msg\_cb for byte transfer) manages the actual data transfer to the display controller. It handles messages like U8X8\_MSG\_BYTE\_START\_TRANSFER (to initiate communication, often by asserting CS), U8X8\_MSG\_BYTE\_SEND (to transmit individual bytes), and U8X8\_MSG\_BYTE\_END\_TRANSFER (to conclude communication, often by de-asserting CS).30 For hardware SPI on the RP2040, this would involve utilizing functions from the Pico SDK's

hardware/spi.h library, such as spi\_init() for initialization, spi\_set\_format() for configuring data bits, clock polarity/phase, and spi\_write\_blocking() for efficient data transmission.48 Integrating U8g2 into a Raspberry Pi Pico project's CMake build system typically involves adding the library's source directories (e.g., using

add\_subdirectory()) and linking the necessary components in the project's CMakeLists.txt file (e.g., using target\_link\_libraries()).57

U8g2's highly flexible memory management, encompassing full buffer, page buffer, and direct write modes, provides a significant strategic advantage for embedded applications with diverse resource constraints. This allows developers to precisely optimize for either maximum performance (using the full buffer for smooth animations) or extreme memory efficiency (employing the page buffer, or U8x8 for text-only displays). This stands in contrast to libraries that might impose a single, fixed memory model. While the initial overhead of implementing a custom Hardware Abstraction Layer (HAL) for bare-metal RP2040 integration requires a deeper technical understanding and more development effort, this investment yields fine-grained control over hardware interactions. This control can lead to highly optimized performance, tailored resource usage, and the ability to address subtle hardware-specific issues. For example, a user reported a "louder buzzing sound" with a U8g2-driven display compared to an Adafruit-driven one.59 This acoustic phenomenon is often linked to the display's internal DC-DC converter or its refresh rate. The SH1107 datasheet specifies parameters like contrast control (0x81) and multiplex ratio (0xA8) which influence display characteristics.27 U8g2's default initialization sequence might use values for these parameters (e.g., 0x02f for contrast, 0x7f for multiplex ratio 59) that differ from Adafruit's (0x4F for contrast 27) or are more aggressive, potentially leading to audible noise. The ability to modify these initialization parameters via U8g2's

sendF() function (e.g., u8g2.sendF("ca", 0x81, 0x4f); u8g2.sendF("ca", 0xa8, 0x7f); to match Adafruit's settings 59) directly demonstrates the power of its low-level abstraction. This capability allows expert users to fine-tune display behavior, debug compatibility issues, and mitigate undesirable side effects like buzzing, which is a significant advantage over libraries with fixed initialization sequences.

#### **Waveshare's C++ Drivers**

Waveshare provides dedicated C/C++ drivers and example code specifically tailored for their Pico-OLED-1.3 module, which is based on the SH1107 driver.60 These drivers incorporate a "bottom hardware interface" layer, typically found in

DEV\_Config.c(.h), which is designed to simplify porting across different hardware platforms.5 This layer exposes functions for module initialization (

DEV\_Module\_Init(), DEV\_Module\_Exit()) and basic GPIO control (DEV\_Digital\_Write(), DEV\_Digital\_Read()). At a higher level, the drivers offer a set of Graphical User Interface (GUI) functions for common drawing primitives, including Paint\_SelectImage(), Paint\_SetMirroring(), Paint\_SetPixel(), Draw line, Draw rectangle, Draw circle, and Show Ascii character.5 They also support image manipulation features such as rotation (

Paint\_SetRotate()).5

Waveshare's examples for the Raspberry Pi Pico are designed for direct integration within the Pico SDK development environment. This involves using CMake to generate Makefiles and compiling .uf2 firmware files for straightforward flashing onto the Pico.5 The underlying SPI communication within Waveshare's drivers frequently leverages Pico SDK functions, most notably

spi\_write\_blocking, to efficiently write the entire framebuffer to the display.4 Furthermore, Waveshare's C/C++ examples for their displays often integrate the LVGL (Light and Versatile Graphics Library) for more advanced graphical user interface operations, managing LVGL initialization (

lv\_init) and task handling (lv\_tick\_inc, lv\_timer\_handler).68

Waveshare's drivers, while offering a direct and pre-configured solution for their specific Pico-OLED-1.3 hardware, represent a hybrid approach to display control. Their DEV\_Config.c(.h) structure suggests an internal hardware abstraction layer, aiming for modularity. However, this abstraction is likely less generic and more tightly coupled to Waveshare's product ecosystem compared to U8g2's universal HAL, which is designed for broader platform adaptation. The reliance on spi\_write\_blocking for full framebuffer updates implies a full-buffer strategy, similar to Adafruit GFX, with comparable memory consumption and potential blocking behavior during display refreshes. The integration of LVGL, while enabling rich and complex user interfaces, inherently increases the overall resource demands (both RAM and CPU cycles) on the RP2040. This suggests a design philosophy geared towards providing feature-rich user interfaces rather than strict minimalism. A significant practical drawback, however, is the documented inconsistency and perceived poor quality of Waveshare's example code and documentation.68 User reviews highlight issues such as incorrect driver download code, hard-to-follow installation processes, and generally clumsy software.78 This can considerably impede development progress and increase the time required for integration, despite the technical capabilities of the drivers themselves. This underscores that the practical usability of a library is not solely determined by its technical features but also by the quality of its supporting resources.

#### **mcu-renderer Library**

The mcu-renderer library is a C-language graphics library specifically engineered for microcontrollers with limited memory. Its primary focus is on rendering non-flickering, anti-aliased text.4 A key differentiating feature of mcu-renderer is its superior font compression ratio, which significantly reduces the Flash memory footprint required for fonts compared to other libraries. Comparative data illustrates mcu-renderer's efficiency in this regard: for a Roboto 12px font, mcu-renderer utilizes 1473 bytes at 1 bit per pixel (bpp), which is more efficient than U8g2's 1508 bytes and Adafruit\_GFX's 3832 bytes.4

The library provides a clear API for drawing various graphical elements, including bitmaps and images, and offers robust text rendering capabilities supporting C-strings, UTF-8, and UTF-16 formats.4 For monochrome displays, mcu-renderer requires a full framebuffer, similar to Adafruit GFX, and mandates explicit calls to

mr\_xxx\_refresh\_screen() to update the display after drawing operations.4 To facilitate font usage, the library includes a

fontconv tool, which enables the conversion of various font formats, such as .bdf, .pcf bitmap fonts, and .ttf, .ttc, .otf, .otc, .woff vector fonts, into mcu-renderer's optimized format.4 The library is designed for low resource utilization, though it still requires a full framebuffer for monochrome displays, positioning its RAM consumption similarly to Adafruit GFX in that aspect. Its primary advantage in memory optimization lies in its efficient font compression, which conserves Flash memory.4

The mcu-renderer library carves out a niche as an alternative optimized for high-quality text rendering with minimal font memory consumption. Its focus on anti-aliased text provides a visually smoother output, which can be a significant aesthetic advantage for user interfaces. This specialization, however, implies a trade-off: while its text rendering capabilities and font compression are excellent, its general graphics primitive set might be less comprehensive or as widely featured as those found in more general-purpose libraries like Adafruit GFX or U8g2. The requirement for a full framebuffer on monochrome displays means its RAM consumption for the display buffer is comparable to Adafruit GFX. However, its superior font compression offers a distinct advantage in terms of Flash memory usage, which can be crucial for applications with extensive textual content or where Flash space is a limiting factor. This makes mcu-renderer a compelling choice when high-quality, memory-efficient text display is a primary requirement, even if it means a potentially less feature-rich graphics API for other drawing operations.

### **Conclusion**

The comparative analysis of display libraries for SH1107 OLEDs on the Raspberry Pi Pico reveals a landscape of diverse architectural philosophies, each with distinct advantages and trade-offs. The choice of library profoundly impacts development effort, resource consumption (RAM and Flash), and the ultimate capabilities of the embedded application.

**Adafruit GFX/SH110X** offers a widely adopted, "batteries-included" approach, particularly within the Arduino ecosystem. Its standardized API and comprehensive set of graphics primitives simplify initial development and allow for relatively quick adaptation across various Adafruit displays. The full framebuffer strategy, while straightforward for drawing, demands 2KB of SRAM for a 128x128 display. While the RP2040's 264KB SRAM easily accommodates this, it represents a fixed memory overhead. A notable complexity arises with custom fonts in Adafruit GFX, where the lack of inherent background color support necessitates manual clearing (potentially causing flicker) or the use of an additional offscreen canvas (increasing RAM usage). The 8MHz SPI bitrate prioritizes speed, but the blocking nature of display updates might affect real-time responsiveness in demanding applications.

**U8g2/U8x8** stands out for its exceptional flexibility in memory management. Its "full buffer," "page buffer," and "direct write" (U8x8) modes allow developers to precisely tailor memory consumption to project needs, from graphic-intensive displays to ultra-low-memory text-only interfaces. This granular control is a significant advantage for highly constrained environments. While integrating U8g2 with the bare-metal Pico SDK requires more initial development effort due to the need for custom Hardware Abstraction Layer (HAL) callbacks, this investment yields fine-grained control over hardware interactions, enabling highly optimized performance and the ability to address specific hardware quirks, such as fine-tuning display parameters to mitigate audible noise. U8g2's highly compressed fonts also contribute to significant Flash memory savings.

**Waveshare's C++ Drivers** provide a product-specific solution for their Pico-OLED-1.3 module, leveraging the Pico SDK and often integrating the LVGL library for rich GUI capabilities. This approach offers pre-configured functionality for their hardware. However, the reliance on a full framebuffer and spi\_write\_blocking implies similar memory consumption and blocking behavior to Adafruit GFX. A critical practical impediment for Waveshare's drivers is the documented inconsistency and perceived poor quality of their example code and documentation, which can significantly increase development time and frustration, despite the technical capabilities of the underlying drivers.

**mcu-renderer** presents a specialized alternative, excelling in low-resource, anti-aliased text rendering with superior font compression. While it requires a full framebuffer for monochrome displays (similar RAM footprint to Adafruit GFX), its efficient font compression significantly reduces Flash memory usage for text-heavy applications. Its graphics primitive set might be less comprehensive than more general-purpose libraries, but its focus on high-quality text output makes it a strong contender for specific use cases.

In conclusion, the optimal library choice depends on the project's priorities:

* For **rapid prototyping and general-purpose graphics** where 2KB+ RAM for the display buffer is acceptable and documentation quality is paramount, **Adafruit GFX/SH110X** is a strong contender, especially if operating within the Arduino IDE environment. Developers should be mindful of the text rendering nuances and potential flicker.  
* For projects with **strict memory constraints, complex real-time requirements, or a need for highly optimized, customized display behavior**, **U8g2/U8x8** is the superior choice. The initial learning curve for its HAL is offset by unparalleled control and efficiency.  
* For **high-quality, memory-efficient text rendering** where font Flash memory is a concern, **mcu-renderer** offers a compelling solution, provided its general graphics capabilities meet project needs.  
* **Waveshare's drivers** are best considered for their specific hardware if the developer is prepared to invest significant time in deciphering potentially inconsistent documentation and examples, or if the integrated LVGL functionality is a critical requirement outweighing ease of setup.

Ultimately, a thorough understanding of each library's architectural decisions and their implications for resource management and development workflow is crucial for making an informed selection that aligns with project goals and available development resources.

#### **Works cited**

1. Interfacing Arduino Board with SH1107 OLED Display in I2C Mode \- Simple Circuit, accessed August 4, 2025, [https://simple-circuit.com/interfacing-arduino-sh1107-oled-display-i2c-mode/](https://simple-circuit.com/interfacing-arduino-sh1107-oled-display-i2c-mode/)  
2. Interfacing Arduino with SH1107 OLED Display in SPI Mode \- Simple Circuit, accessed August 4, 2025, [https://simple-circuit.com/arduino-sh1107-oled-spi-mode-interfacing/](https://simple-circuit.com/arduino-sh1107-oled-spi-mode-interfacing/)  
3. Grove \- OLED Display 1.12 (SH1107) V3.0 \- SPI/IIC \-3.3 V/5V \- Seeed Wiki, accessed August 4, 2025, [https://wiki.seeedstudio.com/Grove-OLED-Display-1.12-SH1107\_V3.0/](https://wiki.seeedstudio.com/Grove-OLED-Display-1.12-SH1107_V3.0/)  
4. SH1107 \- Display Future, accessed August 4, 2025, [https://www.displayfuture.com/Display/datasheet/controller/SH1107.pdf](https://www.displayfuture.com/Display/datasheet/controller/SH1107.pdf)  
5. Pico OLED 1.3 \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-OLED-1.3](https://www.waveshare.com/wiki/Pico-OLED-1.3)  
6. 1.3 inch OLED Display Module for Raspberry Pi Pico, 64×128, SPI/I2C \- Waveshare, accessed August 4, 2025, [https://www.waveshare.com/pico-oled-1.3.htm](https://www.waveshare.com/pico-oled-1.3.htm)  
7. Raspberry Pi Pico W \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Raspberry\_Pi\_Pico\_W](https://www.waveshare.com/wiki/Raspberry_Pi_Pico_W)  
8. Getting Started With Raspberry Pi Pico : 9 Steps \- Instructables, accessed August 4, 2025, [https://www.instructables.com/Getting-Started-With-Raspberry-Pi-Pico/](https://www.instructables.com/Getting-Started-With-Raspberry-Pi-Pico/)  
9. Using the Raspberry Pi Pico C/C++ SDK \- V. Hunter Adams, accessed August 4, 2025, [https://vanhunteradams.com/Pico/Setup/UsingPicoSDK.html](https://vanhunteradams.com/Pico/Setup/UsingPicoSDK.html)  
10. Arduino | Adafruit Monochrome 1.12" 128x128 OLED Graphic Display, accessed August 4, 2025, [https://learn.adafruit.com/adafruit-monochrome-1-12-in-128x128-oled/arduino](https://learn.adafruit.com/adafruit-monochrome-1-12-in-128x128-oled/arduino)  
11. Page buffering for 1.5" OLED display \- Programming \- Arduino Forum, accessed August 4, 2025, [https://forum.arduino.cc/t/page-buffering-for-1-5-oled-display/1222223](https://forum.arduino.cc/t/page-buffering-for-1-5-oled-display/1222223)  
12. Adafruit GFX Graphics Library, accessed August 4, 2025, [https://cdn-learn.adafruit.com/downloads/pdf/adafruit-gfx-graphics-library.pdf](https://cdn-learn.adafruit.com/downloads/pdf/adafruit-gfx-graphics-library.pdf)  
13. Introduction — Adafruit GFX Library 1.0 documentation, accessed August 4, 2025, [https://docs.circuitpython.org/projects/gfx/en/latest/](https://docs.circuitpython.org/projects/gfx/en/latest/)  
14. Overview | Adafruit GFX Graphics Library, accessed August 4, 2025, [https://learn.adafruit.com/adafruit-gfx-graphics-library?view=all](https://learn.adafruit.com/adafruit-gfx-graphics-library?view=all)  
15. Adafruit GFX (Adafruit\_GFX.h) \- Library \- Codebender, accessed August 4, 2025, [https://codebender.cc/library/Adafruit\_GFX](https://codebender.cc/library/Adafruit_GFX)  
16. Adafruit GFX Graphics Library \- Instructables, accessed August 4, 2025, [https://content.instructables.com/F9L/7DNF/JQ2O2BRX/F9L7DNFJQ2O2BRX.pdf](https://content.instructables.com/F9L/7DNF/JQ2O2BRX/F9L7DNFJQ2O2BRX.pdf)  
17. SH1107-Based OLED Display \- DONE.LAND, accessed August 4, 2025, [https://done.land/components/humaninterface/display/oled/sh1107/](https://done.land/components/humaninterface/display/oled/sh1107/)  
18. Adafruit SH110x Arduino Library: Adafruit\_SH110X Class Reference, accessed August 4, 2025, [https://adafruit.github.io/Adafruit\_SH110x/html/class\_adafruit\_\_\_s\_h110\_x.html](https://adafruit.github.io/Adafruit_SH110x/html/class_adafruit___s_h110_x.html)  
19. Using Fonts | Adafruit GFX Graphics Library | Adafruit Learning System, accessed August 4, 2025, [https://learn.adafruit.com/adafruit-gfx-graphics-library/using-fonts](https://learn.adafruit.com/adafruit-gfx-graphics-library/using-fonts)  
20. Creating Custom Symbol Fonts for Adafruit GFX Library, accessed August 4, 2025, [https://learn.adafruit.com/creating-custom-symbol-font-for-adafruit-gfx-library?view=all](https://learn.adafruit.com/creating-custom-symbol-font-for-adafruit-gfx-library?view=all)  
21. Adafruit\_GFX library with fonts \- Displays \- Arduino Forum, accessed August 4, 2025, [https://forum.arduino.cc/t/adafruit\_gfx-library-with-fonts/355903](https://forum.arduino.cc/t/adafruit_gfx-library-with-fonts/355903)  
22. GxFont\_GFX\_TFT\_eSPI/User\_Setup.h at master \- GitHub, accessed August 4, 2025, [https://github.com/ZinggJM/GxFont\_GFX\_TFT\_eSPI/blob/master/User\_Setup.h](https://github.com/ZinggJM/GxFont_GFX_TFT_eSPI/blob/master/User_Setup.h)  
23. Lite version of GFX Library? \- Adafruit Forums, accessed August 4, 2025, [https://forums.adafruit.com/viewtopic.php?t=158200](https://forums.adafruit.com/viewtopic.php?t=158200)  
24. Adafruit SH110X \- Arduino Documentation, accessed August 4, 2025, [https://docs.arduino.cc/libraries/adafruit-sh110x/](https://docs.arduino.cc/libraries/adafruit-sh110x/)  
25. Display \- Arduino Library List, accessed August 4, 2025, [https://www.arduinolibraries.info/categories/display](https://www.arduinolibraries.info/categories/display)  
26. Adafruit\_SH110x/Adafruit\_SH110X.cpp at master · adafruit ... \- GitHub, accessed August 4, 2025, [https://github.com/adafruit/Adafruit\_SH110x/blob/master/Adafruit\_SH110X.cpp](https://github.com/adafruit/Adafruit_SH110x/blob/master/Adafruit_SH110X.cpp)  
27. Adafruit\_SH110x/Adafruit\_SH1107.cpp at master · adafruit ... \- GitHub, accessed August 4, 2025, [https://github.com/adafruit/Adafruit\_SH110x/blob/master/Adafruit\_SH1107.cpp](https://github.com/adafruit/Adafruit_SH110x/blob/master/Adafruit_SH1107.cpp)  
28. Can anyone help me identify some of the pins on this OLED RES and DC specifically I'm pretty sure the rest is just SPI : r/arduino \- Reddit, accessed August 4, 2025, [https://www.reddit.com/r/arduino/comments/upzcdz/can\_anyone\_help\_me\_identify\_some\_of\_the\_pins\_on/](https://www.reddit.com/r/arduino/comments/upzcdz/can_anyone_help_me_identify_some_of_the_pins_on/)  
29. U8g2 \- Arduino Library List, accessed August 4, 2025, [https://www.arduinolibraries.info/libraries/u8g2](https://www.arduinolibraries.info/libraries/u8g2)  
30. Port U8G2 Graphics Library to STM32 – Step‑by‑Step Guide, accessed August 4, 2025, [https://controllerstech.com/how-to-port-u8g2-graphic-lib-to-stm32/](https://controllerstech.com/how-to-port-u8g2-graphic-lib-to-stm32/)  
31. Why does it cut off the second half? More info in comments. Please help. : r/arduino \- Reddit, accessed August 4, 2025, [https://www.reddit.com/r/arduino/comments/e970e6/why\_does\_it\_cut\_off\_the\_second\_half\_more\_info\_in/](https://www.reddit.com/r/arduino/comments/e970e6/why_does_it_cut_off_the_second_half_more_info_in/)  
32. Question regarding ssd1306 and sensor details (using u8g2) \- Displays \- Arduino Forum, accessed August 4, 2025, [https://forum.arduino.cc/t/question-regarding-ssd1306-and-sensor-details-using-u8g2/544574](https://forum.arduino.cc/t/question-regarding-ssd1306-and-sensor-details-using-u8g2/544574)  
33. 6 ways to communicate with STM32 part 4\. Graphics, graphics, and I2C., accessed August 4, 2025, [https://nerd.mmccoo.com/index.php/2018/01/08/6-ways-to-communicate-with-stm32-part-4-graphics-graphics-and-i2c/](https://nerd.mmccoo.com/index.php/2018/01/08/6-ways-to-communicate-with-stm32-part-4-graphics-graphics-and-i2c/)  
34. U8g2 infinite side move \- General Guidance \- Arduino Forum, accessed August 4, 2025, [https://forum.arduino.cc/t/u8g2-infinite-side-move/1239843](https://forum.arduino.cc/t/u8g2-infinite-side-move/1239843)  
35. u8x8setupcpp · olikraus/u8g2 Wiki · GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/u8x8setupcpp](https://github.com/olikraus/u8g2/wiki/u8x8setupcpp)  
36. u8x8reference · olikraus/u8g2 Wiki \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/u8x8reference](https://github.com/olikraus/u8g2/wiki/u8x8reference)  
37. olikraus/u8g2: U8glib library for monochrome displays, version 2 \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2](https://github.com/olikraus/u8g2)  
38. u8g2reference · olikraus/u8g2 Wiki \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/u8g2reference](https://github.com/olikraus/u8g2/wiki/u8g2reference)  
39. Gissio/mcu-renderer: A low-resource graphics library for MCUs with anti-aliased font rendering \- GitHub, accessed August 4, 2025, [https://github.com/Gissio/mcu-renderer](https://github.com/Gissio/mcu-renderer)  
40. Adafruit SSD1306 GFX Lib vs. U8g2 Lib \- Displays \- Arduino Forum, accessed August 4, 2025, [https://forum.arduino.cc/t/adafruit-ssd1306-gfx-lib-vs-u8g2-lib/471361](https://forum.arduino.cc/t/adafruit-ssd1306-gfx-lib-vs-u8g2-lib/471361)  
41. fntlist8 · olikraus/u8g2 Wiki \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/fntlist8](https://github.com/olikraus/u8g2/wiki/fntlist8)  
42. fntlistallplain · olikraus/u8g2 Wiki · GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/fntlistallplain](https://github.com/olikraus/u8g2/wiki/fntlistallplain)  
43. fntlist16 · olikraus/u8g2 Wiki \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/fntlist16](https://github.com/olikraus/u8g2/wiki/fntlist16)  
44. fntlist8 U8g2 Font List U8g2 Font Names \- Ardustore.dk, accessed August 4, 2025, [https://ardustore.dk/error/Skrift%20OLED%20-%20Ardustore.dk.pdf](https://ardustore.dk/error/Skrift%20OLED%20-%20Ardustore.dk.pdf)  
45. Porting to new MCU platform · olikraus/u8g2 Wiki \- GitHub, accessed August 4, 2025, [https://github.com/olikraus/u8g2/wiki/Porting-to-new-MCU-platform](https://github.com/olikraus/u8g2/wiki/Porting-to-new-MCU-platform)  
46. Raspberry Pi Pico SDK: hardware\_gpio \- Lorenz Ruprecht, accessed August 4, 2025, [https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/group\_\_hardware\_\_gpio.html](https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/group__hardware__gpio.html)  
47. Programming the Raspberry Pi Pico in C \- IOPress, accessed August 4, 2025, [https://www.iopress.info/index.php/books/9-programs/52-picocprograms](https://www.iopress.info/index.php/books/9-programs/52-picocprograms)  
48. Raspberry Pi Pico SDK: hardware\_spi \- Lorenz Ruprecht, accessed August 4, 2025, [https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/group\_\_hardware\_\_spi.html](https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/group__hardware__spi.html)  
49. Raspberry Pi Pico (RP2040) SPI Example with MicroPython and C/C++ \- DigiKey, accessed August 4, 2025, [https://www.digikey.com/en/maker/projects/raspberry-pi-pico-rp2040-spi-example-with-micropython-and-cc/9706ea0cf3784ee98e35ff49188ee045](https://www.digikey.com/en/maker/projects/raspberry-pi-pico-rp2040-spi-example-with-micropython-and-cc/9706ea0cf3784ee98e35ff49188ee045)  
50. Raspberry Pi Pico SDK: hardware\_spi/include/hardware/spi.h File ..., accessed August 4, 2025, [https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/rp2\_\_common\_2hardware\_\_spi\_2include\_2hardware\_2spi\_8h.html](https://lorenz-ruprecht.at/docu/pico-sdk/1.4.0/html/rp2__common_2hardware__spi_2include_2hardware_2spi_8h.html)  
51. Raspberry Pi Pico SDK: hardware\_spi/include/hardware/spi.h File Reference, accessed August 4, 2025, [https://cec-code-lab.aps.edu/robotics/resources/pico-c-api/rp2\_\_common\_2hardware\_\_spi\_2include\_2hardware\_2spi\_8h.html](https://cec-code-lab.aps.edu/robotics/resources/pico-c-api/rp2__common_2hardware__spi_2include_2hardware_2spi_8h.html)  
52. Raspberry Pi Pico SDK: hardware\_spi/include/hardware/spi.h Source File \- CEC-Code-Lab, accessed August 4, 2025, [https://cec-code-lab.aps.edu/robotics/resources/pico-c-api/rp2\_\_common\_2hardware\_\_spi\_2include\_2hardware\_2spi\_8h\_source.html](https://cec-code-lab.aps.edu/robotics/resources/pico-c-api/rp2__common_2hardware__spi_2include_2hardware_2spi_8h_source.html)  
53. Raspberry Pi Pico (RP2040) SPI Example with MicroPython and C/C++ | Digi-Key Electronics \- YouTube, accessed August 4, 2025, [https://www.youtube.com/watch?v=jdCnqiov6es](https://www.youtube.com/watch?v=jdCnqiov6es)  
54. Read value from SPI on Raspberry Pi Pico using Rust \- Stack Overflow, accessed August 4, 2025, [https://stackoverflow.com/questions/76382019/read-value-from-spi-on-raspberry-pi-pico-using-rust](https://stackoverflow.com/questions/76382019/read-value-from-spi-on-raspberry-pi-pico-using-rust)  
55. rp2040\_hal::spi \- Rust \- Docs.rs, accessed August 4, 2025, [https://docs.rs/rp2040-hal/latest/rp2040\_hal/spi/index.html](https://docs.rs/rp2040-hal/latest/rp2040_hal/spi/index.html)  
56. Making Two Raspberry Pi Pico Boards Communicate through SPI using C/C++ SDK, accessed August 4, 2025, [https://staging.circuitstate.com/tutorials/making-two-raspberry-pi-pico-boards-communicate-through-spi-using-c-cpp-sdk/](https://staging.circuitstate.com/tutorials/making-two-raspberry-pi-pico-boards-communicate-through-spi-using-c-cpp-sdk/)  
57. Pi pico : Cmake and new project creation \- Raspberry Pi Forums, accessed August 4, 2025, [https://forums.raspberrypi.com/viewtopic.php?t=349107](https://forums.raspberrypi.com/viewtopic.php?t=349107)  
58. CMake: Adding u8g2 library \- Raspberry Pi Forums, accessed August 4, 2025, [https://forums.raspberrypi.com/viewtopic.php?t=311492](https://forums.raspberrypi.com/viewtopic.php?t=311492)  
59. SH1107 i2c display low frame rate? · Issue \#2158 · olikraus/u8g2 ..., accessed August 4, 2025, [https://github.com/olikraus/u8g2/issues/2158](https://github.com/olikraus/u8g2/issues/2158)  
60. Waveshare 1.3inch OLED Display Module for Raspberry Pi Pico, accessed August 4, 2025, [https://docs.zephyrproject.org/latest/boards/shields/waveshare\_pico\_oled\_1\_3/doc/index.html](https://docs.zephyrproject.org/latest/boards/shields/waveshare_pico_oled_1_3/doc/index.html)  
61. Raspberry Pi Pico-OLED-1.3 User Guide \- Spotpear, accessed August 4, 2025, [https://spotpear.com/index/study/detail/id/566.html](https://spotpear.com/index/study/detail/id/566.html)  
62. 1.3" OLED Display Module for Raspberry Pi Pico (64×128) \- Model rocket shop, accessed August 4, 2025, [https://modelrockets.co.uk/electronics-and-payloads/displays/1-3-oled-display-module-for-raspberry-pi-pico-64128/](https://modelrockets.co.uk/electronics-and-payloads/displays/1-3-oled-display-module-for-raspberry-pi-pico-64128/)  
63. 1.3inch OLED Display Module for Raspberry Pi Pico, 64×128, SPI/I2C \- PiShop.us, accessed August 4, 2025, [https://www.pishop.us/product/1-3inch-oled-display-module-for-raspberry-pi-pico-64-128-spi-i2c/](https://www.pishop.us/product/1-3inch-oled-display-module-for-raspberry-pi-pico-64-128-spi-i2c/)  
64. waveshare 1.3 inch OLED Display for Raspberry Pi Pico, 64×128 Pixels, Embedded SH1107 Driver, Using SPI/I2C Bus, Better Compatibility, Fast Data Rate \- Newegg, accessed August 4, 2025, [https://www.newegg.com/waveshare-barebone-systems-mini-pc-other/p/2SW-004U-002A6](https://www.newegg.com/waveshare-barebone-systems-mini-pc-other/p/2SW-004U-002A6)  
65. waveshare 1.3inch OLED Display 64×128 Pixels OLED Module for Raspberry Pi Pico Microcontroller Board, Embedded SH1107 Driver,SPI and I2C Interface \- Newegg, accessed August 4, 2025, [https://www.newegg.com/waveshare-barebone-systems-mini-pc-other/p/2SW-004U-002M9](https://www.newegg.com/waveshare-barebone-systems-mini-pc-other/p/2SW-004U-002M9)  
66. Waveshare 1.3inch OLED Display Module for Raspberry Pi Pico, 64×128 Pixels, 4-Wire SPI and I2C Interface Embedded SH1107 Driver with Two User Buttons for Easy Interacting in Oman | Whizz Single Board Computers, accessed August 4, 2025, [https://oman.whizzcart.com/product/20040064/waveshare-1-3inch-oled-display-module-for-raspberry-pi-pico-64-128-pixels-4-wire-spi-and-i2c-interface-embedded-sh1107-driver-with-two-user-buttons-for-easy-interacting/](https://oman.whizzcart.com/product/20040064/waveshare-1-3inch-oled-display-module-for-raspberry-pi-pico-64-128-pixels-4-wire-spi-and-i2c-interface-embedded-sh1107-driver-with-two-user-buttons-for-easy-interacting/)  
67. Pico e-Paper 4.2 \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-ePaper-4.2](https://www.waveshare.com/wiki/Pico-ePaper-4.2)  
68. Pico LCD 1.3 \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-LCD-1.3](https://www.waveshare.com/wiki/Pico-LCD-1.3)  
69. Pico LCD 1.8 \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-LCD-1.8](https://www.waveshare.com/wiki/Pico-LCD-1.8)  
70. Sound Sensor \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Sound\_Sensor](https://www.waveshare.com/wiki/Sound_Sensor)  
71. Pico-8SEG-LED \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-8SEG-LED](https://www.waveshare.com/wiki/Pico-8SEG-LED)  
72. Pico-CAN-B \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-CAN-B](https://www.waveshare.com/wiki/Pico-CAN-B)  
73. Raspberry Pi Pico \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Raspberry\_Pi\_Pico](https://www.waveshare.com/wiki/Raspberry_Pi_Pico)  
74. Pico RGB LED \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-RGB-LED](https://www.waveshare.com/wiki/Pico-RGB-LED)  
75. Pico-Get-Start-Windows \- Waveshare Wiki, accessed August 4, 2025, [https://www.waveshare.com/wiki/Pico-Get-Start-Windows](https://www.waveshare.com/wiki/Pico-Get-Start-Windows)  
76. C/C++ drivers for WaveShare 3.5 inch LCD display for the Pico \- Raspberry Pi Forums, accessed August 4, 2025, [https://forums.raspberrypi.com/viewtopic.php?t=382292](https://forums.raspberrypi.com/viewtopic.php?t=382292)  
77. i2c\_read\_blocking() causes pico to hang \- Raspberry Pi Forums, accessed August 4, 2025, [https://forums.raspberrypi.com/viewtopic.php?t=366890](https://forums.raspberrypi.com/viewtopic.php?t=366890)  
78. 1.3" OLED Display Module for Raspberry Pi Pico (64×128) \- The Pi Hut, accessed August 4, 2025, [https://thepihut.com/products/1-3-oled-display-module-for-raspberry-pi-pico-64x128](https://thepihut.com/products/1-3-oled-display-module-for-raspberry-pi-pico-64x128)